mtime:1741376717.5100195
{"name": "RPA.JSON", "doc": "JSON is a library for manipulating [JSON](http://json.org/) files and strings.\n\nJSON is a common data interchange format inspired by a subset of\nthe Javascript programming language, but these days is a de facto\nstandard in modern web APIs and is language agnostic.\n\n## Serialization\n\nThe term serialization refers to the process of converting\nRobot Framework or Python types to JSON or the other way around.\n\nBasic types can be easily converted between the domains,\nand the mapping is as follows:\n\n\n\n\n\nJSON\n\nPython\n\nobject\n\ndict\n\narray\n\nlist\n\nstring\n\nstr\n\nnumber (int)\n\nint\n\nnumber (real)\n\nfloat\n\ntrue\n\nTrue\n\nfalse\n\nFalse\n\nnull\n\nNone## About JSONPath\n\nReading and writing values from/to JSON serializable objects is done\nusing [JSONPath](http://goessner.net/articles/JsonPath/). It's a syntax designed to quickly and easily refer to\nspecific elements in a JSON structure. The specific flavor used in this\nlibrary is based on [jsonpath-ng](https://pypi.org/project/jsonpath-ng/#description).\n\nCompared to Python's normal dictionary access, JSONPath expressions can\ntarget multiple elements through features such as conditionals and wildcards,\nwhich can simplify many JSON-related operations. It's analogous to XPath\nfor XML structures.\n\n### Syntax example\n\nFor this example consider the following structure:\n\n```json\n{\n  \"clients\": [\n    {\n      \"name\": \"Johnny Example\",\n      \"email\": \"john@example.com\",\n      \"orders\": [\n          {\"address\": \"Streetroad 123\", \"price\": 103.20},\n          {\"address\": \"Streetroad 123\", \"price\": 98.99}\n      ]\n    },\n    {\n      \"name\": \"Jane Example\",\n      \"email\": \"jane@example.com\",\n      \"orders\": [\n          {\"address\": \"Waypath 321\", \"price\": 22.00},\n          {\"address\": \"Streetroad 123\", \"price\": 2330.01}\n      ]\n    }\n  ]\n}\n```\n\nIn the simplest case JSONPath can replace nested access:\n\n```robotframework\n*** Tasks ***\nNested access\n    # First order of first client, with direct dictionary access\n    ${value}=    Set variable    ${json}[\"clients\"][0][\"orders\"][0]\n\n    # JSONPath access\n    ${value}=    Get value from JSON    ${json}    $.clients[0].orders[0]\n```\n\nBut the power comes from complicated expressions:\n\n```robotframework\n*** Tasks ***\nComplicated expressions\n    # Find delivery addresses for all orders\n    ${prices}=        Get values from JSON    $..address\n\n    # Find orders that cost over 100\n    ${expensives}=    Get values from JSON    $..orders[?(@.price>100)]\n```\n\n### Supported Expressions\n\nThe supported syntax elements are:\n\n\n\n\n\nElement\n\nDescription\n\n$\n\nRoot object/element\n\n@\n\nCurrent object/element inside expressions\n\n. or \\[\\]\n\nChild operator\n\n..\n\nRecursive descendant operator\n\n``parent``\n\nParent operator, see functions\n\n\\*\n\nWilcard, any element\n\n,\n\nSelect multiple fields\n\n\\[n\\]\n\nArray index\n\n\\[a:b:c\\]\n\nArray slice (start, end, step)\n\n\\[a,b\\]\n\nUnion of indices or names\n\n\\[?()\\]\n\nApply a filter expression\n\n()\n\nScript expression\n\n\\[\\\\field\\]\n\nSort descending by field, cannot be combined with\nfilters.\n\n\\[/field\\]\n\nSort ascending by field, cannot be combined with\nfilters.\n\n``str()``\n\nConvert value to string, see functions\n\n``sub()``\n\nRegex substitution function, see functions\n\n``len``\n\nCalculate value's length, see functions\n\n``split()``\n\nString split function, see functions\n\n+ - \\* /\n\nArithmetic functions, see functions#### Functions\n\nThis library allows JSON path expressions to include certain functions\nwhich can provide additional benefit to users. These functions are\ngenerally encapsulated in backticks (`\\``). Some functions require\nyou to pass arguments similar to a Python function.\n\nFor example, let's say a JSON has nodes on the JSON path\n`$.books[\\*].genres` which are represented as strings of genres with\ncommas separating each genre. So for one book, this node might have a\nvalue like `horror,young-adult`. You can return a list of first genre\nfor each book by using the `split` function like so:\n\n```robotframework\n*** Task ***\nGet genres\n    ${genres}=  Get values from JSON    $.books[*].genres.```split(,, 0, -1)```\n```\n\nEach functions parameters are defined here:\n\n\n\n\n\nFunction\n\nUsage\n\nstr()\n\nNo parameters, but parenthesis are required\n\nsub(/regex/, repl)\n\nThe regex pattern must be provided in regex\nand the replacement value provided in repl\n\nlen\n\nNo parameters and no parenthesis\n\nsplit(char, segment, max\\_split)\n\nSeparator character provided as char, which\nindex from the resulting array to be returns\nprovided as segment, and maximum number of\nsplits to perform provided as max\\_split,\n-1 for all splits.\n\nparent\n\nNo parameters, no parenthesis**Arithmetic Functions**\n\nJSON Path can be written and combined to concatenate string values\nor perform arithmetic functions on numerical values. Each JSONPath\nexpression used must return the same type, and when performing\nsuch functions between returned lists, each list must be the same\nlength. An example is included in documentation for the keyword\n`Get values from JSON`.\n\n#### Additional Information\n\nThere are a multitude of different script expressions\nin addition to the elements listed above, which can\nbe seen in the [aforementioned article](http://goessner.net/articles/JsonPath/).\n\nFor further library usage examples, see the individual keywords.\n", "version": null, "specversion": "6", "type": "LIBRARY", "scope": "GLOBAL", "docFormat": "markdown", "source": "C:\\Users\\Gustavo Zanotto\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\RPA\\JSON.py", "lineno": 40, "tags": [], "inits": [], "keywords": [{"name": "Add to JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "expr", "kind": "POSITIONAL_OR_NAMED", "repr": "expr: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}, {"name": "value", "kind": "POSITIONAL_OR_NAMED", "repr": "value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}], "doc": "Add items into a JSON serializable object and return the result.\n\nIf the target is a list, the values are appended to the end.\nIf the target is a dict, the keys are either added or updated.\n\nparam doc\n\n:   JSON serializable object\n\nparam expr\n\n:   JSONPath expression\n\nparam value\n\n:   values to either append or update\n\nreturn\n\n:   JSON serializable object of the updated JSON\n\nRobot Framework Example:\n\n```robotframework\n*** Task ***\nChange the name value for all people\n    &{before}=    Convert string to JSON   {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\n    &{person}=    Create dictionary      Name=John\n    &{after}=     Add to JSON    ${before}   $.People    ${person}\n```\n\nPython Example:\n\n```python\nfrom RPA.JSON import JSON\n\n# Change the name value for all people\njs = JSON()\nbefore = js.convert_string_to_json('{\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}')\nperson = {\"Name\": \"John\"}\nafter = js.add_to_json(before, \"$.People\", person)\n\nprint(after)\n```\n", "tags": [], "source": null, "shortdoc": "Add items into a JSON serializable object and return the result.", "lineno": 372}, {"name": "Convert JSON to String", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}], "doc": "Convert a JSON serializable object to a string and return it.\n\nparam doc\n\n:   JSON serializable object\n\nreturn\n\n:   string of the JSON serializable object\n\nRobot Framework Example:\n\n```robotframework\n*** Task ***\nConvert to string\n    ${obj}=    Create dictionary    Key=Value\n    ${json}=   Convert JSON to string    ${obj}\n    Should be equal    ${json}     {\"Key\": \"Value\"}\n```\n\nPython Example:\n\n```python\nfrom RPA.JSON import JSON\nfrom robot.libraries.BuiltIn import BuiltIn\n\nobj = {\"Key\": \"Value\"}\njson = JSON().convert_json_to_string(obj)\nBuiltIn().should_be_equal(json, '{\"Key\": \"Value\"}')\n```\n", "tags": [], "source": null, "shortdoc": "Convert a JSON serializable object to a string and return it.", "lineno": 310}, {"name": "Convert String to JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}], "doc": "Convert a string to a JSON serializable object and return it.\n\nparam doc\n\n:   JSON string\n\nreturn\n\n:   JSON serializable object of the string\n\nRobot Framework Example:\n\n```robotframework\n*** Task ***\nConvert to json\n    ${json}=    Set variable    {\"Key\": \"Value\"}\n    &{obj}=     Convert string to JSON    ${json}\n    Should be equal    ${obj.Key}    Value\n```\n\nPython Example:\n\n```python\nfrom RPA.JSON import JSON\nfrom robot.libraries.BuiltIn import BuiltIn\n\njson = '{\"Key\": \"Value\"}'\nobj = JSON().convert_string_to_json(json)\nBuiltIn().should_be_equal(obj[\"Key\"], \"Value\")\n```\n", "tags": [], "source": null, "shortdoc": "Convert a string to a JSON serializable object and return it.", "lineno": 341}, {"name": "Delete from JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "expr", "kind": "POSITIONAL_OR_NAMED", "repr": "expr: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}], "doc": "Delete values from a JSON serializable object and return the result.\nWill delete all values that match the expression.\n\nparam doc\n\n:   JSON serializable object or string\n\nparam expr\n\n:   JSONPath expression\n\nreturn\n\n:   JSON serializable object with values removed\n\nExample:\n\n```robotframework\n*** Task ***\nDelete all people\n    &{before}=    Convert string to JSON   {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\n    &{after}=     Delete from JSON    ${before}   $.People[*]\n```\n\n```python\nfrom RPA.JSON import JSON\n\n# Delete all people\nbefore = {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\nafter = JSON().delete_from_json(before, \"$.People[*]\")\nprint(after)\n```\n", "tags": [], "source": null, "shortdoc": "Delete values from a JSON serializable object and return the result. Will delete all values that match the expression.", "lineno": 709}, {"name": "Get value from JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "expr", "kind": "POSITIONAL_OR_NAMED", "repr": "expr: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}, {"name": "default", "kind": "POSITIONAL_OR_NAMED", "repr": "default: Any | None = None", "required": true, "defaultValue": "None", "types": ["Union"], "typedocs": []}], "doc": "Get a single value from a JSON serializable object that matches the given expression.\n\nRaises a ValueError if there is more than one match.\nReturns the given default argument (or None) if there\nwere no matches.\n\nparam doc\n\n:   JSON serializable object or string\n\nparam expr\n\n:   jsonpath expression\n\nparam default\n\n:   default value to return in the absence of a match\n\nreturn\n\n:   string containing the match OR default if there are no matches\n\nraises ValueError\n\n:   if more than one match is discovered\n\nShort Robot Framework Example:\n\n```robotframework\n*** Task ***\nGet the name value for the first person\n    &{people}=    Convert string to JSON   {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\n    ${first}=     Get value from JSON      ${people}   $.People[0].Name\n```\n\nShort Python Example:\n\n```python\nfrom RPA.JSON import JSON\n\n# Get the name value for the second person.\npeople = {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\nsecond = JSON().get_value_from_json(people, \"$.People[1].Name\")\nprint(second)\n```\n\nExtended Robot Framework Example:\n\n```robotframework\n*** Settings ***\nLibrary         RPA.JSON\nSuite Setup     Ingest JSON\n\n*** Variables ***\n${JSON_STRING}      {\n...                   \"clients\": [\n...                     {\n...                       \"name\": \"Johnny Example\",\n...                       \"email\": \"john@example.com\",\n...                       \"orders\": [\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 103.20, \"id\":\"guid-001\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 98.99, \"id\":\"guid-002\"}\n...                       ]\n...                     },\n...                     {\n...                       \"name\": \"Jane Example\",\n...                       \"email\": \"jane@example.com\",\n...                       \"orders\": [\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 22.00, \"id\":\"guid-003\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 2330.01, \"id\":\"guid-004\"},\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 152.12, \"id\":\"guid-005\"}\n...                       ]\n...                     }\n...                   ]\n...                 }\n${ID}               guid-003\n\n*** Tasks ***\nGet email for specific order id\n    ${email}=    Get value from json    ${JSON_DOC}    $.clients[?(@..id==\"${ID}\")].email\n    Log    \\nOUTPUT IS\\n ${email}    console=${True}\n    Should be equal as strings    ${email}    jane@example.com\n\n*** Keywords ***\nIngest JSON\n    ${doc}=    Convert string to json    ${JSON_STRING}\n    Set suite variable    ${JSON_DOC}    ${doc}\n```\n", "tags": [], "source": null, "shortdoc": "Get a single value from a JSON serializable object that matches the given expression.", "lineno": 417}, {"name": "Get values from JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "expr", "kind": "POSITIONAL_OR_NAMED", "repr": "expr: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}], "doc": "Get all values from a JSON serializable object that match the given expression.\n\nparam doc\n\n:   JSON serializable object or string\n\nparam expr\n\n:   JSONPath expression\n\nreturn\n\n:   list of values that match\n\nShort Robot Framework Example:\n\n```robotframework\n*** Task ***\nGet all the names for all people\n    &{people}=    Convert string to JSON   {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\n    @{names}=     Get values from JSON     ${people}   $.People[*].Name\n```\n\nShort Python Example:\n\n```python\nfrom RPA.JSON import JSON\n\n# Get all the names for all people\npeople = {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\nnames = JSON().get_values_from_json(people, \"$.People[*].Name\")\nprint(second)\n```\n\nExtended Robot Framework Example:\n\n```robotframework\n*** Settings ***\nLibrary         RPA.JSON\nSuite Setup     Ingest JSON\n\n*** Variables ***\n${JSON_STRING}      {\n...                   \"clients\": [\n...                     {\n...                       \"name\": \"Johnny Example\",\n...                       \"email\": \"john@example.com\",\n...                       \"orders\": [\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 103.20, \"id\":\"guid-001\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 98.99, \"id\":\"guid-002\"}\n...                       ]\n...                     },\n...                     {\n...                       \"name\": \"Jane Example\",\n...                       \"email\": \"jane@example.com\",\n...                       \"orders\": [\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 22.00, \"id\":\"guid-003\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 2330.01, \"id\":\"guid-004\"},\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 152.12, \"id\":\"guid-005\"}\n...                       ]\n...                     }\n...                   ]\n...                 }\n${ID}               guid-003\n\n*** Tasks ***\nGet All Prices and Order Ids\n    # Arithmetic operations only work when lists are of equal lengths and types.\n    ${prices}=    Get values from json\n    ...    ${JSON_DOC}\n    ...    $.clients[*].orders[*].id + \" has price \" + $.clients[*].orders[*].price.```str()```\n    Log    \\nOUTPUT IS\\n ${prices}    console=${True}\n    Should be equal as strings    ${prices}\n    ...    ['guid-001 has price 103.2', 'guid-002 has price 98.99', 'guid-003 has price 22.0', 'guid-004 has price 2330.01', 'guid-005 has price 152.12']\n\nFind Only Valid Emails With Regex\n    # The regex used in this example is simplistic and\n    # will not work with all email addresses\n    ${emails}=    Get values from json\n    ...    ${JSON_DOC}\n    ...    $.clients[?(@.email =~ \"[a-zA-Z]+@[a-zA-Z]+\\.[a-zA-Z]+\")].email\n    Log    \\nOUTPUT IS\\n ${emails}    console=${True}\n    Should be equal as strings    ${emails}    ['john@example.com', 'jane@example.com']\n\nFind Orders From Texas Over 100\n    # The regex used in this example is simplistic and\n    # will not work with all email addresses\n    ${orders}=    Get values from json\n    ...    ${JSON_DOC}\n    ...    $.clients[*].orders[?(@.price > 100 & @.state == \"TX\")]\n    Log    \\nOUTPUT IS\\n ${orders}    console=${True}\n    Should be equal as strings    ${orders}\n    ...    [{'address': 'Streetroad 123', 'state': 'TX', 'price': 103.2, 'id': 'guid-001'}, {'address': 'Streetroad 123', 'state': 'TX', 'price': 2330.01, 'id': 'guid-004'}]\n\n\n*** Keywords ***\nIngest JSON\n    ${doc}=    Convert string to json    ${JSON_STRING}\n    Set suite variable    ${JSON_DOC}    ${doc}\n```\n", "tags": [], "source": null, "shortdoc": "Get all values from a JSON serializable object that match the given expression.", "lineno": 508}, {"name": "Load JSON from file", "args": [{"name": "filename", "kind": "POSITIONAL_OR_NAMED", "repr": "filename: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}, {"name": "encoding", "kind": "POSITIONAL_OR_NAMED", "repr": "encoding=utf-8", "required": true, "defaultValue": "utf-8", "types": [], "typedocs": []}], "doc": "Load JSON data from a file, and return it as JSON serializable object.\nDepending on the input file the object can be either a dictionary,\na list, or a scalar value.\n\nparam filename\n\n:   path to input file\n\nparam encoding\n\n:   file character encoding\n\nreturn\n\n:   JSON serializable object of the JSON file\n\nExample:\n\n```robotframework\n*** Task ***\nLoad json\n    &{auth}=    Load JSON from file    auth.json\n    Log   Current auth token: ${auth.token}\n```\n", "tags": [], "source": null, "shortdoc": "Load JSON data from a file, and return it as JSON serializable object. Depending on the input file the object can be either a dictionary, a list, or a scalar value.", "lineno": 238}, {"name": "Save JSON to file", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "filename", "kind": "POSITIONAL_OR_NAMED", "repr": "filename: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}, {"name": "indent", "kind": "POSITIONAL_OR_NAMED", "repr": "indent: int | None = None", "required": true, "defaultValue": "None", "types": ["Union"], "typedocs": []}, {"name": "encoding", "kind": "POSITIONAL_OR_NAMED", "repr": "encoding: str = utf-8", "required": true, "defaultValue": "utf-8", "types": ["str"], "typedocs": []}], "doc": "Save a JSON serializable object or a string containing\na JSON value into a file.\n\nparam doc\n\n:   JSON serializable object or string\n\nparam filename\n\n:   path to output file\n\nparam indent\n\n:   if given this value is used for json file indent\n\nparam encoding\n\n:   file character encoding\n\nRobot Framework Example:\n\n```robotframework\n*** Tasks ***\nSave dictionary to file\n    ${john}=    Create dictionary    name=John    mail=john@example.com\n    Save JSON to file    ${john}    john.json\n\nSave string to file\n    ${mark}=    Set variable    {\"name\": \"Mark\", \"mail\": \"mark@example.com\"}\n    Save JSON to file    ${mark}    mark.json\n```\n\nPython Example:\n\n```python\nfrom RPA.JSON import JSON\n\n# Save dictionary to file.\njohn = {\"name\": \"John\", \"mail\": \"john@example.com\"}\nJSON().save_json_to_file(john, \"john.json\")\n```\n", "tags": [], "source": null, "shortdoc": "Save a JSON serializable object or a string containing a JSON value into a file.", "lineno": 262}, {"name": "Update value to JSON", "args": [{"name": "doc", "kind": "POSITIONAL_OR_NAMED", "repr": "doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}, {"name": "expr", "kind": "POSITIONAL_OR_NAMED", "repr": "expr: str", "required": true, "defaultValue": null, "types": ["str"], "typedocs": []}, {"name": "value", "kind": "POSITIONAL_OR_NAMED", "repr": "value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None", "required": true, "defaultValue": null, "types": ["Union"], "typedocs": []}], "doc": "Update existing values in a JSON serializable object and return the result.\nWill change all values that match the expression.\n\nparam doc\n\n:   JSON or string\n\nparam expr\n\n:   JSONPath expression\n\nparam value\n\n:   New value for the matching item(s)\n\nreturn\n\n:   JSON serializable object with updated results\n\nShort Robot Framework Example:\n\n```robotframework\n*** Tasks ***\nChange the name key for all people\n    &{before}=    Convert string to JSON   {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\n    &{after}=     Update value to JSON     ${before}   $.People[*].Name    JohnMalkovich\n```\n\n```python\nfrom RPA.JSON import JSON\n\n# Change the name key for all people\nbefore = {\"People\": [{\"Name\": \"Mark\"}, {\"Name\": \"Jane\"}]}\nafter = JSON().update_value_to_json(before, \"$.People[*].Name\",\"JohnMalkovich\")\nprint(after)\n```\n\nExtended Robot Framework Example:\n\n```robotframework\n*** Settings ***\nLibrary         RPA.JSON\nLibrary    Collections\nSuite Setup     Ingest JSON\n\n*** Variables ***\n${JSON_STRING}      {\n...                   \"clients\": [\n...                     {\n...                       \"name\": \"Johnny Example\",\n...                       \"email\": \"john@example.com\",\n...                       \"id\": \"user-001\",\n...                       \"orders\": [\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 103.20, \"id\":\"guid-001\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 98.99, \"id\":\"guid-002\"}\n...                       ]\n...                     },\n...                     {\n...                       \"name\": \"Jane Example\",\n...                       \"email\": \"jane@example.com\",\n...                       \"id\": \"user-002\",\n...                       \"orders\": [\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 22.00, \"id\":\"guid-003\"},\n...                         {\"address\": \"Streetroad 123\", \"state\": \"TX\", \"price\": 2330.01, \"id\":\"guid-004\"},\n...                         {\"address\": \"Waypath 321\", \"state\": \"WA\", \"price\": 152.12, \"id\":\"guid-005\"}\n...                       ]\n...                     }\n...                   ]\n...                 }\n${ID}               guid-003\n\n*** Tasks ***\nUpdate user email\n    ${updated_doc}=    Update value to json\n    ...    ${JSON_DOC}\n    ...    $.clients[?(@.id==\"user-001\")].email\n    ...    johnny@example.com\n    Log    \\nNEW JSON IS\\n ${updated_doc}    console=${True}\n    ${new_email}=    Get value from json    ${updated_doc}    $.clients[?(@.id==\"user-001\")].email\n    Should be equal as strings    ${new_email}    johnny@example.com\n\nAdd additional charge to all prices in WA\n    # This example also shows how the update keyword changes the original JSON doc in memory.\n    ${id_price}=    Get values from json\n    ...    ${JSON_DOC}\n    ...    $.clients[*].orders[?(@.state==\"WA\")].id,price\n    FOR    ${order_id}    ${price}    IN    @{id_price}\n        Update value to json    ${JSON_DOC}    $.clients[*].orders[?(@.id==\"${order_id}\")].price    ${{${price} * 1.06}}\n    END\n    Log    \\nNEW JSON IS\\n ${JSON_DOC}    console=${True}\n    ${one_price}=    Get value from json    ${JSON_DOC}    $..orders[?(@.id==${ID})].price\n    Should be equal as numbers    ${one_price}    23.32\n\n*** Keywords ***\nIngest JSON\n    ${doc}=    Convert string to json    ${JSON_STRING}\n    Set suite variable    ${JSON_DOC}    ${doc}\n```\n", "tags": [], "source": null, "shortdoc": "Update existing values in a JSON serializable object and return the result. Will change all values that match the expression.", "lineno": 607}], "dataTypes": {}, "typedocs": []}